{% extends "base.html" %}
{% load static %}

{% block content %}
<style>
  :root{
    --bg: #0b0f14;
    --panel: #0f1620;
    --panel2: #0c121a;
    --border: rgba(255,255,255,0.10);
    --text: #ffffff;
    --muted: rgba(255,255,255,0.70);
    --muted2: rgba(255,255,255,0.55);
    --good: #3ddc84;
    --bad: #ff5c5c;
    --warn: #ffcc00;
    --accent: #4cc9f0;
  }

  .exp-wrap{
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 18px;
    padding: 18px;
    color: var(--text);
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  }

  .exp-topbar{
    display:flex;
    gap: 12px;
    align-items:center;
    justify-content: space-between;
    margin-bottom: 14px;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.04);
    color: var(--text);
    font-weight: 700;
  }

  .muted{ color: var(--muted); font-weight: 600; }
  .muted2{ color: var(--muted2); font-weight: 600; }

  .grid{
    display:grid;
    grid-template-columns: 1.2fr 0.8fr;
    gap: 14px;
  }

  @media (max-width: 992px){
    .grid{ grid-template-columns: 1fr; }
  }

  .panel{
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px;
  }

  .panel h5{
    margin: 0 0 10px 0;
    font-weight: 800;
    letter-spacing: 0.2px;
  }

  .players{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
  }

  @media (max-width: 992px){
    .players{ grid-template-columns: 1fr; }
  }

  .p-card{
    position:relative;
    background: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 12px;
    min-height: 170px;
    overflow:hidden;
  }

  .p-card.empty{
    background: #05070a;
    border: 1px solid rgba(255,255,255,0.08);
  }

  .p-card.empty:after{
    content:"";
    position:absolute;
    inset:-40px;
    background: linear-gradient(135deg,
      rgba(255,255,255,0) 47%,
      rgba(255,255,255,0.10) 50%,
      rgba(255,255,255,0) 53%);
    transform: rotate(0deg);
    pointer-events:none;
  }

  .p-head{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 10px;
  }

  .avatar{
    width: 44px;
    height: 44px;
    border-radius: 12px;
    background: rgba(255,255,255,0.06);
    border: 1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size: 18px;
  }

  .p-name{
    font-weight: 900;
    font-size: 14px;
    margin: 0;
    line-height: 1.1;
    color: var(--text);
  }

  .p-sub{
    font-size: 12px;
    color: var(--muted);
    margin-top: 2px;
    font-weight: 700;
  }

  .badge-vote{
    font-size: 12px;
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.04);
    font-weight: 800;
  }
  .badge-vote.ok{ color: var(--good); }
  .badge-vote.wait{ color: var(--warn); }

  .statrow{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 8px;
  }

  .stat{
    flex: 1;
    min-width: 90px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 8px 10px;
  }

  .stat .k{
    font-size: 11px;
    color: var(--muted);
    font-weight: 800;
    letter-spacing: 0.2px;
  }
  .stat .v{
    font-size: 14px;
    font-weight: 900;
    color: var(--text);
    margin-top: 2px;
  }

  .hpbar{
    height: 10px;
    border-radius: 999px;
    background: rgba(255,255,255,0.08);
    border: 1px solid var(--border);
    overflow:hidden;
    margin-top: 8px;
  }
  .hpbar > div{
    height:100%;
    background: linear-gradient(90deg, rgba(61,220,132,1), rgba(76,201,240,1));
    width: 0%;
    transition: width 0.25s ease;
  }

  .actions{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 10px;
  }

  .btn-exp{
    border-radius: 12px;
    font-weight: 900;
  }

  .phase-box{
    display:flex;
    flex-direction: column;
    gap: 8px;
  }

  .phase-line{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.04);
  }

  .phase-title{
    font-weight: 900;
    color: var(--text);
  }

  .timer{
    font-weight: 900;
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.35);
    color: var(--accent);
    min-width: 80px;
    text-align:center;
  }

  .enemy-box{
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 12px;
    background: rgba(255,255,255,0.04);
  }

  .enemy-title{
    font-weight: 900;
    margin-bottom: 6px;
  }

  .decision-box{
    border: 1px dashed rgba(255,255,255,0.22);
    border-radius: 14px;
    padding: 12px;
    background: rgba(255,255,255,0.03);
  }

  .decision-title{
    font-weight: 900;
    margin-bottom: 4px;
    color: var(--warn);
  }

  /* ‚úÖ Resultado visual (no rompe nada) */
  .result-box{
    border: 1px solid rgba(76,201,240,0.35);
    background: rgba(76,201,240,0.08);
  }
  .result-title{
    font-weight: 900;
    margin-bottom: 4px;
    color: var(--accent);
  }

  .chat-wrap{
    display:flex;
    flex-direction: column;
    height: 420px;
  }

  .chat-log{
    flex:1;
    overflow:auto;
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 10px;
    background: rgba(0,0,0,0.35);
    color: var(--text);
  }

  .chat-msg{
    margin: 0 0 6px 0;
    font-size: 13px;
  }

  .chat-msg b{
    color: var(--accent);
  }

  .chat-input{
    display:flex;
    gap: 8px;
    margin-top: 10px;
  }

  .chat-input input{
    flex:1;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.04);
    color: var(--text);
    padding: 10px 12px;
    font-weight: 700;
    outline: none;
  }

  .chat-input input::placeholder{
    color: rgba(255,255,255,0.45);
  }
</style>

<div class="exp-wrap">
  <div class="exp-topbar">
    <div class="d-flex gap-2 flex-wrap">
      <span class="pill">üß≠ Expedici√≥n <span class="muted">#{{ lobby.id }}</span></span>
      <span class="pill">üîë C√≥digo <span class="muted">{{ lobby.code }}</span></span>
      <span class="pill">üèîÔ∏è Piso <span class="muted" id="floorText">{{ lobby.floor }}</span></span>
    </div>
    <div class="d-flex gap-2 flex-wrap">
      <a class="btn btn-sm btn-outline-light btn-exp" href="{% url 'expeditions_hub' %}">‚Üê Volver</a>
      {% if user.id == lobby.creator_id %}
      <form method="post" action="{% url 'expeditions_start' lobby.id %}">
        {% csrf_token %}
        <button class="btn btn-sm btn-success btn-exp" type="submit">‚ñ∂ Iniciar</button>
      </form>
      {% endif %}
    </div>
    {% if lobby.status == "waiting" %}
        <form method="post" action="{% url 'expeditions_leave' lobby.id %}">
        {% csrf_token %}
        <button class="btn btn-sm btn-danger btn-exp" type="submit">üö™ Salir</button>
        </form>
    {% endif %}
  </div>

  <div class="grid">
    <!-- IZQ: HUD + Jugadores -->
    <div class="panel">
      <h5>üë• Jugadores</h5>
      <div class="players" id="playersGrid"></div>

      <div class="panel mt-3" style="background:transparent; border:none; padding:0;">
        <div class="phase-box">
          <div class="phase-line">
            <div>
              <div class="phase-title" id="phaseTitle">Fase: ...</div>
              <div class="muted2" id="phaseHint">Esperando...</div>
            </div>
            <div class="timer" id="timerBox">--:--</div>
          </div>

          <div class="enemy-box" id="enemyBox" style="display:none;">
            <div class="enemy-title">üëπ Enemigo del piso</div>
            <div class="muted2" id="enemyStats">HP: - | ATK: - | DEF: -</div>
          </div>

          <div class="decision-box" id="decisionBox" style="display:none;">
            <div class="decision-title">üé≤ Evento Aleatorio</div>
            <div class="muted2" id="decisionText">...</div>
          </div>

          <!-- ‚úÖ Nuevo: Resultado visual -->
          <div class="decision-box result-box" id="resultBox" style="display:none;">
            <div class="result-title">‚ú® Resultado</div>
            <div class="muted2" id="resultText">...</div>
          </div>

          <div class="muted2" id="voteHelp"></div>
        </div>
      </div>
    </div>

    <!-- DER: CHAT -->
    <div class="panel">
      <h5>üí¨ Chat</h5>
      <div class="chat-wrap">
        <div class="chat-log" id="chatLog"></div>
        <div class="chat-input">
          <input id="chatInput" type="text" placeholder="Escribe un mensaje..." maxlength="300">
          <button class="btn btn-primary btn-exp" id="chatSendBtn">Enviar</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const lobbyId = {{ lobby.id }};
  const wsScheme = (window.location.protocol === "https:") ? "wss" : "ws";
  const wsUrl = `${wsScheme}://${window.location.host}/ws/expediciones/${lobbyId}/`;
  const socket = new WebSocket(wsUrl);

  let lastState = null;
  let tickInterval = null;
  let uiInterval = null;
  let lastEffectHash = null;
  let hideResultTimeout = null;

  // Para que el chat NO se borre mientras escribes:
  let chatDraft = "";
  const chatInput = document.getElementById("chatInput");
  chatInput.addEventListener("input", () => {
    chatDraft = chatInput.value;
  });

  function phaseLabel(phase){
    const map = {
      "waiting": "Esperando jugadores",
      "vote_order_1": "Votaci√≥n: qui√©n va primero",
      "vote_order_2": "Votaci√≥n: qui√©n va segundo",
      "decision": "Decisi√≥n",
      "show_result": "Resultado",
      "combat": "Combate",
      "between": "Entre pisos",
      "ended": "Terminada",
    };
    return map[phase] || phase;
  }

  // Helpers texto
  function statName(stat){
    if(stat === "hp") return "Vida";
    if(stat === "attack") return "Ataque";
    if(stat === "defense") return "Defensa";
    return stat ?? "Stat";
  }
  function fmtDelta(n){
    if(n == null) return "?";
    const x = Number(n);
    if(!Number.isFinite(x)) return "?";
    return x >= 0 ? `+${x}` : `${x}`;
  }
  function fmtPct(n){
    if(n == null) return "?%";
    const x = Number(n);
    if(!Number.isFinite(x)) return "?%";
    return x >= 0 ? `+${x}%` : `${x}%`;
  }

  // ‚úÖ Texto del evento en curso (antes de votar)
function decisionLabel(d){
  if(!d) return "";
  const type = d.type;
  const p = d.payload || {};

  // Compatibilidad con tus antiguos
  if(type === "heal_50") return "Curar 50% HP a un jugador.";
  if(type === "damage_30") return "Quitar 30% HP a un jugador.";
  if(type === "give_stats") return `Dar +${p.amount ?? "?"} a ${p.stat ?? "stat"}.`;
  if(type === "remove_stats") return `Quitar -${p.amount ?? "?"} a ${p.stat ?? "stat"}.`;

  switch(type){
    case "stat_boon_small":
      return `‚ú® Bendici√≥n menor: ${fmtDelta(p.delta)} ${statName(p.stat)} (permanente).`;
    case "stat_boon_big":
      return `üåü Bendici√≥n mayor: ${fmtDelta(p.delta)} ${statName(p.stat)} (permanente).`;
    case "stat_curse_small":
      return `üíÄ Maldici√≥n menor: ${fmtDelta(p.delta)} ${statName(p.stat)} (permanente).`;
    case "stat_curse_big":
      return `‚ò†Ô∏è Maldici√≥n mayor: ${fmtDelta(p.delta)} ${statName(p.stat)} (permanente).`;
    case "gamble_spike":
      return `üé≤ Apuesta salvaje: gran cambio aleatorio en ${statName(p.stat)} (puede subir o bajar).`;
    case "reroll_split":
      return `üîÄ Reparto ca√≥tico: mover ${p.amount ?? "?"} de ${statName(p.from)} a ${statName(p.to)}.`;
    case "life_trade":
      return `‚ù§Ô∏è‚Äçü©π Intercambio vital: +${p.hp_gain ?? "?"} Vida, ${fmtDelta(p.penalty)} ${statName(p.penalty_stat)}.`;
    case "glass_cannon":
      return `üíé Ca√±√≥n de cristal: +${p.atk_gain ?? "?"} Ataque, ${fmtDelta(p.def_loss)} Defensa.`;
    case "turtle":
      return `üê¢ Coraza: +${p.def_gain ?? "?"} Defensa, ${fmtDelta(p.atk_loss)} Ataque.`;
    case "berserk":
      return `ü©∏ Berserk: +${p.atk_gain ?? "?"} Ataque, ${fmtDelta(p.hp_loss)} Vida m√°xima.`;
    case "bloodpact":
      if(p.mode === "atk_up_hp_down"){
        return `ü©∏ Pacto de sangre: +${p.atk ?? "?"} Ataque, ${fmtDelta(p.hp)} Vida.`;
      }
      return `ü©∏ Pacto de sangre: +${p.hp ?? "?"} Vida, ${fmtDelta(p.atk)} Ataque.`;
    case "fortune_wheel":
      return `üé° Rueda de la fortuna: resultado permanente aleatorio.`;

    case "hp_percent_shift":
      return `‚ù§Ô∏è Cambio vital: ${fmtPct(p.pct)} Vida m√°xima (permanente).`;
    case "atk_percent_shift":
      return `‚öîÔ∏è Cambio ofensivo: ${fmtPct(p.pct)} Ataque (permanente).`;
    case "def_percent_shift":
      return `üõ°Ô∏è Cambio defensivo: ${fmtPct(p.pct)} Defensa (permanente).`;

    // ‚úÖ NUEVOS: curaciones (solo current_hp, NO cambia max_hp)
    case "heal_pct_small":
      return `üíö Curaci√≥n menor: +${p.pct ?? "?"}% de vida actual (sin cambiar vida m√°xima).`;
    case "heal_pct_big":
      return `üíö Curaci√≥n mayor: +${p.pct ?? "?"}% de vida actual (sin cambiar vida m√°xima).`;
    case "heal_flat_small":
      return `üß™ Curaci√≥n plana menor: +${p.amount ?? "?"} HP actual (sin cambiar vida m√°xima).`;
    case "heal_flat_big":
      return `üß™ Curaci√≥n plana mayor: +${p.amount ?? "?"} HP actual (sin cambiar vida m√°xima).`;
    case "heal_to_full":
      return `‚ú® Curaci√≥n total: llenar la vida actual al m√°ximo.`;

    default:
      return type;
  }
}


  // ‚úÖ Texto del resultado aplicado (despu√©s de votar / auto-resolver)
  function effectLabel(e){
    if(!e) return "";
    const t = e.type;
    const target = e.target ?? "?";

    // caso gen√©rico delta
    if(e.stat && (e.delta !== undefined)){
      return `Jugador ${target}: ${fmtDelta(e.delta)} ${statName(e.stat)}.`;
    }

    // reroll_split
    if(e.from && e.to && (e.amount !== undefined)){
      return `Jugador ${target}: -${e.amount} ${statName(e.from)} y +${e.amount} ${statName(e.to)}.`;
    }

    // percent shift (si devuelves pct+diff desde backend)
    if(e.stat && (e.pct !== undefined)){
      const diffTxt = (e.diff !== undefined) ? ` (${fmtDelta(e.diff)} puntos)` : "";
      return `Jugador ${target}: ${fmtPct(e.pct)} ${statName(e.stat)}${diffTxt}.`;
    }

    // paquetes
    if(t === "life_trade"){
      return `Jugador ${target}: +${e.hp_gain} Vida y ${fmtDelta(e.penalty)} ${statName(e.penalty_stat)}.`;
    }
    if(t === "glass_cannon"){
      return `Jugador ${target}: +${e.atk_gain} Ataque y ${fmtDelta(e.def_loss)} Defensa.`;
    }
    if(t === "turtle"){
      return `Jugador ${target}: +${e.def_gain} Defensa y ${fmtDelta(e.atk_loss)} Ataque.`;
    }
    if(t === "berserk"){
      return `Jugador ${target}: +${e.atk_gain} Ataque y ${fmtDelta(e.hp_loss)} Vida m√°xima.`;
    }
    if(t === "bloodpact"){
      if(e.mode === "atk_up_hp_down"){
        return `Jugador ${target}: +${e.atk} Ataque y ${fmtDelta(e.hp)} Vida.`;
      }
      return `Jugador ${target}: +${e.hp} Vida y ${fmtDelta(e.atk)} Ataque.`;
    }

    // fallback seguro
    try { return JSON.stringify(e); } catch { return String(e); }
  }

  function safeNum(n, fallback=0){
    const x = Number(n);
    return Number.isFinite(x) ? x : fallback;
  }

  function renderPlayers(players, lobby){
    const grid = document.getElementById("playersGrid");
    grid.innerHTML = "";

    const votes = lobby.votes || [];
    const phase = lobby.phase;
    const votedIds = votes.filter(v => v.phase === phase).map(v => v.voter_id);

    players.forEach((p, idx) => {
      if(!p){
        const div = document.createElement("div");
        div.className = "p-card empty";
        div.innerHTML = `
          <div class="p-head">
            <div class="d-flex align-items-center gap-2">
              <div class="avatar">‚ùî</div>
              <div>
                <p class="p-name">Slot vac√≠o</p>
                <div class="p-sub">Esperando jugador...</div>
              </div>
            </div>
            <span class="badge-vote wait">‚Äî</span>
          </div>
          <div class="muted2">No hay nadie aqu√≠.</div>
        `;
        grid.appendChild(div);
        return;
      }

      const isVoted = votedIds.includes(p.user_id);
      const maxHp = safeNum(p.max_hp, 1);
      const curHp = safeNum(p.current_hp, 0);
      const hpPct = Math.max(0, Math.min(100, Math.round((curHp / Math.max(maxHp,1)) * 100)));

      const card = document.createElement("div");
      card.className = "p-card";
      card.innerHTML = `
        <div class="p-head">
          <div class="d-flex align-items-center gap-2">
            <div class="avatar">üßë</div>
            <div>
              <p class="p-name">${p.user__username}</p>
              <div class="p-sub">${p.is_alive ? "üü¢ Vivo" : "üî¥ Muerto"}</div>
            </div>
          </div>
          <span class="badge-vote ${isVoted ? "ok" : "wait"}">
            ${isVoted ? "üó≥Ô∏è Vot√≥" : "‚åõ No vot√≥"}
          </span>
        </div>

        <div class="statrow">
          <div class="stat">
            <div class="k">HP</div>
            <div class="v">${curHp} / ${maxHp}</div>
          </div>
          <div class="stat">
            <div class="k">ATK</div>
            <div class="v">${p.attack}</div>
          </div>
          <div class="stat">
            <div class="k">DEF</div>
            <div class="v">${p.defense}</div>
          </div>
        </div>

        <div class="hpbar"><div style="width:${hpPct}%"></div></div>

        <div class="actions">
          <button class="btn btn-sm btn-outline-light btn-exp" ${!p.is_alive ? "disabled":""} onclick="voteFor(${p.user_id})">
            Votar por ${p.user__username}
          </button>
        </div>
      `;
      grid.appendChild(card);
    });
  }

  function updatePhaseUI(lobby){
    const phase = lobby.phase;
    document.getElementById("phaseTitle").textContent = `Fase: ${phaseLabel(phase)}`;

    const aliveCount = (lastState?.players || []).filter(p => p && p.is_alive).length;

    let hint = "";
    if(phase === "vote_order_1"){
      hint = (aliveCount <= 1) ? "Solo queda 1 jugador vivo: orden autom√°tico." : "Voten qui√©n pelea primero.";
    }
    else if(phase === "vote_order_2"){
      hint = "Voten qui√©n pelea segundo.";
    }
    else if(phase === "decision"){
      hint = (aliveCount <= 1) ? "Decisi√≥n autom√°tica (solo queda 1 jugador vivo)." : "Decisi√≥n opcional: voten el objetivo.";
    }
    else if(phase === "show_result"){
      hint = "Aplicando efecto...";
    }
    else if(phase === "combat"){
      hint = "Combate en curso...";
    }
    else if(phase === "waiting"){
      hint = "Esperando jugadores / iniciar.";
    }
    else if(phase === "ended"){
      hint = "Expedici√≥n terminada.";
    }
    document.getElementById("phaseHint").textContent = hint;

    // Enemy
    const enemyBox = document.getElementById("enemyBox");
    if(lobby.enemy){
      enemyBox.style.display = "block";
      document.getElementById("enemyStats").textContent =
        `HP: ${lobby.enemy.hp} | ATK: ${lobby.enemy.attack} | DEF: ${lobby.enemy.defense}`;
    }else{
      enemyBox.style.display = "none";
    }

    // Decision (evento antes de aplicar)
    const decisionBox = document.getElementById("decisionBox");
    if(lobby.decision && phase === "decision"){
      decisionBox.style.display = "block";
      document.getElementById("decisionText").textContent = decisionLabel(lobby.decision);
    }else{
      decisionBox.style.display = "none";
    }

    // Resultado (pausa)
    const resultBox = document.getElementById("resultBox");
    if(lobby.last_effect){
      resultBox.style.display = "block";
      document.getElementById("resultText").textContent = effectLabel(lobby.last_effect);
    }else{
      resultBox.style.display = "none";
    }

    // Vote help
    const vh = document.getElementById("voteHelp");
    if(phase === "vote_order_1" || phase === "vote_order_2" || phase === "decision"){
      vh.textContent = (aliveCount <= 1)
        ? ""
        : "Tip: en cuanto TODOS los jugadores vivos voten, se avanza sin esperar los 20s.";
    }else{
      vh.textContent = "";
    }
  }

  function renderChat(chat){
    const log = document.getElementById("chatLog");
    const wasNearBottom = (log.scrollTop + log.clientHeight) >= (log.scrollHeight - 30);

    log.innerHTML = "";
    chat.forEach(m => {
      const p = document.createElement("p");
      p.className = "chat-msg";
      p.innerHTML = `<b>${m.user}:</b> ${escapeHtml(m.msg)}`;
      log.appendChild(p);
    });

    if(wasNearBottom) log.scrollTop = log.scrollHeight;
  }

  function escapeHtml(s){
    return (s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;");
  }

  function voteFor(userId){
    if(!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({type:"vote", target_user_id: userId}));
  }

  function sendChat(){
    const msg = chatInput.value.trim();
    if(!msg) return;
    socket.send(JSON.stringify({type:"chat", msg}));
    chatInput.value = "";
    chatDraft = "";
  }

  document.getElementById("chatSendBtn").addEventListener("click", sendChat);
  chatInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      e.preventDefault();
      sendChat();
    }
  });

  function updateTimer(deadlineIso){
    const box = document.getElementById("timerBox");
    if(!deadlineIso){
      box.textContent = "--:--";
      return;
    }
    const dl = new Date(deadlineIso).getTime();
    const now = Date.now();
    const diff = Math.max(0, dl - now);
    const sec = Math.floor(diff / 1000);
    const mm = String(Math.floor(sec / 60)).padStart(2,"0");
    const ss = String(sec % 60).padStart(2,"0");
    box.textContent = `${mm}:${ss}`;
  }

  socket.onopen = () => {
    tickInterval = setInterval(() => {
      if(socket.readyState === WebSocket.OPEN){
        socket.send(JSON.stringify({type:"tick"}));
      }
    }, 1000);

    uiInterval = setInterval(() => {
      if(lastState?.lobby?.deadline){
        updateTimer(lastState.lobby.deadline);
      }else{
        updateTimer(null);
      }
    }, 250);
  };

  socket.onclose = () => {
    if(tickInterval) clearInterval(tickInterval);
    if(uiInterval) clearInterval(uiInterval);
  };

  socket.onmessage = (ev) => {
    const payload = JSON.parse(ev.data);
    if(payload.type !== "state") return;

    lastState = payload.data;
    // Auto-ocultar resultado si cambia
    const effect = lastState?.lobby?.last_effect;
    const effectStr = effect ? JSON.stringify(effect) : null;

    if (effectStr && effectStr !== lastEffectHash) {
      lastEffectHash = effectStr;

      if (hideResultTimeout) clearTimeout(hideResultTimeout);
      hideResultTimeout = setTimeout(() => {
        const box = document.getElementById("resultBox");
        if (box) box.style.display = "none";
      }, 2000);
    }


    if(chatDraft && chatInput.value !== chatDraft){
      chatInput.value = chatDraft;
    }

    document.getElementById("floorText").textContent = lastState.lobby.floor;

    renderPlayers(lastState.players, lastState.lobby);
    updatePhaseUI(lastState.lobby);
    renderChat(lastState.chat);
  };
</script>
{% endblock %}
